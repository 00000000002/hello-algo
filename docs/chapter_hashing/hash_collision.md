---
comments: true
---

# 哈希冲突处理

理想情况下，哈希函数应该为每个输入产生唯一的输出，使得 key 和 value 一一对应。而实际上，可能存在多个输入产生相同输出的情况，即 key 和 value 存在多对一的关系，即「哈希冲突 Hash Collision」。

「哈希冲突」会严重影响哈希表的实用性。试想一下，如果在哈希表中总是查找到错误的结果，亦或无法新建冲突的键值对，那么我们肯定不会继续使用这样的数据结构了。

即使我们设计了一个足够好的「哈希函数」，仍然无法杜绝哈希冲突问题，这是因为：

- 哈希表的桶（地址）的大小是有限的，在数据量足够大时，
- 尽量使哈希冲突均匀分布，

哈希冲突的常见的解决方案有「链式地址」和「开放寻址」。

## 链式地址

「链式地址」通过引入链表来解决哈希冲突问题，代价是占用空间变大，因为链表或二叉树包含结点指针，相比于数组更加耗费内存空间。

### 链表

原始哈希表中一个桶地址只能存储一个元素（即键值对），因此无法处理冲突。「链式地址」考虑将桶地址内的单个元素转变成一个链表，将所有冲突元素都存储在一个链表中。 

- **查询元素：** 先将 key 输入到哈希函数得到桶地址（即访问链表头部），再遍历链表来确定对应的 value 。
- **添加元素：** 先通过哈希函数访问链表头部，再将元素直接添加到链表头部即可。
- **删除元素：** 同样先访问链表头部，再遍历链表查找对应元素，删除之即可。

（图）

### 二叉树

引入链表虽然解决了哈希冲突，但查询效率也随之降低了，因为需要线性查找（即遍历链表）来确认对应元素。为了缓解此问题，当某个桶地址内的链表太长时，可以将链表转化为「平衡二叉搜索树」，将时间复杂度降低至 $O(\log n)$ 。

!!! note "工业界方案"

    Java 使用了链式地址解决哈希冲突问题，并且在 JDK 1.8 之后， HashMap 内长度大于 8 的链表会被转化为「红黑树」，以提升查找性能。

## 开放寻址

「开放寻址」不引入额外数据结构，而是通过 “向后探测” 来解决哈希冲突。根据探测方法的不同，主要分为 **线性探测、平方探测、多次哈希**。

### 线性探测

「线性探测」利用线性查找来解决哈希冲突，具体为：

- **插入元素：** 如果出现哈希冲突，则从冲突位置向后线性遍历（一般步长取 1 ），直到找到一个空位，则将元素插入到该空位中。
- **查找元素：** 若出现哈希冲突，则使用相同步长执行线性查找，会遇到两种情况：
  1. 找到对应元素，返回 value 即可；

  2. 若遇到空位，则说明查找键值对不在哈希表中；


（图）

线性探测有以下缺陷：

- 不能直接删除元素。删除元素后，桶内出现一个空槽，在查找其他元素时，该空槽有可能导致程序认为元素不存在（即上述第 `2.` 种情况）。因此，需要借助额外的 `flag` 来标记删除元素。
- 容易产生聚集。桶内被占用的连续位置越长，这些连续位置发生哈希冲突的可能性越大，从而进一步促进这一位置的 “聚堆生长” ，最终导致增删查改操作效率的劣化。

### 多次哈希

顾名思义，「多次哈希」的思路是准备多个哈希函数 $f_1(x)$ , $f_2(x)$ , $f_3(x)$ , ... ，具体操作为：

- **插入元素：** 若哈希函数 $f_1(x)$ 出现冲突，则尝试 $f_2(x)$ ，以此类推……直到找到空位后插入元素；
- **查找元素：** 以相同的哈希函数顺序查找，存在两种情况：
  1. 找到目标元素，则返回之；
  2. 遇到空位或已尝试所有哈希函数，说明哈希表中无此元素；

相比于「线性探测」，「多次哈希」方法更不容易产生聚集，代价是多个哈希函数增加了额外计算量。
